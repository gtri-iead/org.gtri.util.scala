Jan18
Working on rewrite

#1: Hard to be idiomatic about Continue/Failure/Success since there are 3 different Result types. Should Enumerator, Iteratee and Plan Result be collapsed into one Result class?
#1a: Doing this would result in an overflow val in the Enumerator Result that is never used
#1b: Doing this would result in an input type for the Enumerator Result that is never used
#1ba: The input type could be mapped to Unit for Enumerator
#1bb: Would result in pointless computations trying to accumulate the Unit overflow (when composing or folding Results)
#1b: While possibly removing extra Result classes that are nearly identical, it would introduce awkwardness.
#1c: Couldn't this overall concept be combined with OptRecover?
#1ca: Could Result be replaced with OptRecover?
#1caa: What about overflow? What about Issues?

#2: Should there be a top-level Machine class?
#2a: Are there any behaviors or data that Enumerator, Plan and Iteratee all share?
#2aa: They all have an initial State. All States could be viewed as accepting input (Unit in case of Enumerator) and generating a Result from the input
#2b: What about endOfInput signal. Does this make sense for Enumerator?
#2ba: Not really, but endOfInput could just be a noop in Enumerator.
#2bb: It could indicate that no further "step" calls will be made.
#2bc: Could be used to close resources in the enumerator since no further steps will occur
#2bca: Generally this isn't necessary since most enumerators are run to completion?
#2bcaa: This is a bad assumption since the whole point is the Iteratee may say it is done before the Enumerator is done

#3: Should List[O], List[I] be changed to just O,I?
#3a: Not all machines accept one input and generate one output. Some machines may accept input generate no output or accept a single input and generate many outputs
#3aa: For those machines, couldn't the O or I just be set to a List[...]?
#3aaa: This would mean that to accumulate a result, O must be a Monoid. Also I, for accumulating overflow
#3aaaa: Does overflow need to accumulate? Yes, for composing at a minimum
#3b: O,I would need a way to represent "empty" most likely Monoid.zero
#3c: While this makes this library simpler in design by making it more generic, it probably won't simplify the use of it by later code, but will instead complicate it.

#4: There appear to be two distinct "types" of machines: 1) continuous output machines (enumerators, translators) and machines that only output on success (iteratee).
Currently, this distinction is ignored. This leads to difficulty using the classes idiomatically
#4a: XXX[I,O] could be modified to XXX[I,S,O] where I is input-type, S state-type and O is output-type. S is present in Continue/Failure/Success, O is only present in Success

#5: Should Issue be eliminated in favor of later classes rolling it into O?
#5a: This creates problems with List[O], specifically:
#5aa: XmlReader would need to be Enumerator[(XmlEvent, List[Issue])]
#5ab: XmlWriter would need to be Iteratee[XmlEvent,Issue]
#5ac: XmlToXsdParser would need to be Iteratee[XmlEvent,(XsdEvent,List[Issue])]
#5b: How would you get issues out if there was no output?

#6: Should Issue be replaced with a simple Metadata trait
#6a: "Metadata" can always be safely ignored if not understood.
#6aa: Are Issues really Metadata? Aren't we planning on looking at Issue output to determine whether to continue?

Jan 23

#1: Should State store a "state" variable? Currently, the TransitionFunction is the "state" variable which is weird.
#1a: For now, renamed TransitionFunction to Transitor to take into account that it is really the combination of State(Continue) & TransitionFunction

#2: Should O be a Monoid instead of Seq[O] or should Seq[O] be M[O] where M is a Monad, to allow for composing monads, e.g. Writer[E,O]
#2a: Would not apply to I or overflow I. I could still be a composed monad such as LogWriter[I].
#2b: A better question would be to address what the requirements are for accumulating "metadata" or "issues" since this is the primary problem. Monads are just one way to solve that problem. (that might have extra benefits)

#3: What are the requirements for accumulating "metadata" or "issues" during SM processing?
#3a: When composing or folding two states, must be able to accumulate the metadata/issues from both
#3aa: If M[O] was used instead of Seq[O] (say M = Writer[List(Issue),Seq[O]]) then Monoid accumulation can be used for folding
#3ab: When composing how would the M[O] of m0 connect to the input of m1?
#3aba: Hopefully by mapping the output out of the monad?
#3abaa: Would this work when the return type of applying input is a State? You would get back M[State[I,O,A]] which doesn't make sense

#4: Should there be a Result trait that contains the output & overflow?
#4a: output & overflow are not really part of state

Jan 24

#1: Moving value from Result.Success to State.Success. This is required to convert a given state to a result.

#2: Should optRecover be moved from Result.Success to State.Success?

#3: Should StateMachine include a type for the set of possible states? StateMachine[I,O,A] => StateMachine[∑,Γ,S,F <: S]
#3a: This is more aligned to the mathematical model, but how would Continue/Success/Failure work? How could a value be
extracted from a final state? How would you compose machines? How would you fold results?
#3ab: trait State[S,F <: S] { def fold[X](isS: S => X, isF: F => X) : X } StateMachine[∑,Γ,S <: State[S,F],F <: S]


